from typing import List
from phi.tools import Toolkit
from phi.utils.log import logger
import requests
from collections import Counter, defaultdict


class SpotifyPlaylistTools(Toolkit):
    def __init__(self, access_token: str):
        super().__init__(name="spotity_playlist_tools")
        self.register(self.get_user_id)
        self.register(self.search_songs_uris)
        self.register(self.create_playlist_by_uris)
        self.register(self.get_spotify_playlist_info)
        self.register(self.start_playlist_playback)
        self.register(self.get_top_artists_and_top_genres_time_range)
        self.register(self.get_followed_artists_and_top_genres_all_life)

        self.access_token = access_token

    def get_user_id(self) -> str:
        """
        Make a request to Spotify API to get user information

        Returns:
            str: the user id of the spotify user
        """
        logger.info(f"Running get_user_id with access token")
        try:
            user_url = "https://api.spotify.com/v1/me"
            headers = {"Authorization": f"Bearer {self.access_token}"}

            user_response = requests.get(user_url, headers=headers)
            logger.debug(f"Result: {user_response}")

            if user_response.status_code != 200:
                msg = f"Failed to get user id. Status code: {user_response.status_code}"
                logger.warning(msg)
                return f"Error: {msg}"

            user_data = user_response.json()
            user_id = user_data["id"]

            return user_id
        except Exception as e:
            logger.warning(f"Error invoking get_user_id: {e}")
            return f"Error: {e}"

    def search_songs_uris(self, song_titles: List[str]) -> List[str]:
        """
        Userful to search the songs uri on spotify and return the list of uris of each song.

        Args:
            song_titles : List[str] : A list of song titles to search on spotify

        Returns:
            List[str] : The list of songs uris found on spotify

        """
        logger.info(f"Running search_songs_uris with access token")
        try:
            if not self.access_token:
                return "Error: No access token provided."

            url = "https://api.spotify.com/v1/search"
            headers = {
                "Authorization": f"Bearer {self.access_token}",
            }

            songs_uris = []
            for song_title in song_titles:
                params = {"q": song_title, "type": "track", "market": "IT", "limit": 1}

                logger.debug(f"Searching for song: {song_title}")
                response = requests.get(url, params=params, headers=headers)
                logger.debug(f"Result: {response}")

                if response.status_code != 200:
                    logger.warning(
                        "Failed to fetch track URI. Status code:", response.status_code
                    )
                    continue

                data = response.json()
                if (
                    "tracks" in data
                    and "items" in data["tracks"]
                    and len(data["tracks"]["items"]) > 0
                ):
                    track_uri = data["tracks"]["items"][0]["uri"]
                    songs_uris.append(f"the song uri of {song_title} is : {track_uri}")
                else:
                    logger.info("No track found.")

            return "\n".join(songs_uris)
        except Exception as e:
            logger.warning(f"Error invoking search_songs_uris: {e}")
            return f"Error: {e}"

    def create_playlist_by_uris(
        self,
        songs_uris: List[str],
        playlist_name="made by NTTLuke (with Phidata)",
    ) -> str:
        """
        Userful to create a playlist on spotify by using the uris of the songs and returns the playlist id
        Uris of the songs can be retrieved using search_songs_uris method

        Args:
            songs_uris : List[str] : The list of songs uris to add to the playlist.
            playlist_name : str : The name of the playlist to create

        Returns
            str: the playlist id of the created playlist
        """

        logger.info(f"Running create_playlist_by_uris")
        try:

            user_id = self.get_user_id()

            url = f"https://api.spotify.com/v1/users/{user_id}/playlists"
            headers = {
                "Authorization": f"Bearer {self.access_token}",
                "Content-Type": "application/json",
            }
            data = {
                "name": playlist_name,
                "description": "generated by phidata",
                "public": False,
            }

            logger.debug(f"Creating playlist: {playlist_name}")

            # Create the playlist
            response = requests.post(url, headers=headers, json=data)
            logger.debug(f"Result: {response}")

            if response.status_code == 201 or response.status_code == 200:
                playlist_data = response.json()
                playlist_id = playlist_data.get("id")

                logger.info(f"Playlist created successfully with ID: {playlist_id}")

                data = {"uris": songs_uris, "position": 0}

                # Add songs to the playlist
                response = requests.post(
                    f"https://api.spotify.com/v1/playlists/{playlist_id}/tracks",
                    headers=headers,
                    json=data,
                )
                if response.status_code == 201 or response.status_code == 200:
                    logger.info("Songs added to the playlist successfully.")
                    return f"Created a new playlist with Playlist ID={playlist_id}"
                else:
                    logger.warning(
                        "Failed to add songs to the playlist. Status code:",
                        response.status_code,
                    )

                    return f"Playlist created with but failed to add songs. Playlist ID: {playlist_id}"

            else:
                logger.warning(
                    f"Failed to create playlist. Status code:{response.status_code}"
                )
                return None

        except Exception as e:
            logger.warning(f"Error invoking create_playlist_by_uris: {e}")
            return f"Error creating playlist: {e}"

    def get_spotify_playlist_info(self, max_number: int = 5) -> dict:
        """
        Get the list of playlist name of the user
        Args:
            max_number : int : The maximum number of playlists to return (default 5)
        """
        try:
            url = f"https://api.spotify.com/v1/me/playlists?limit={max_number}"
            headers = {"Authorization": f"Bearer {self.access_token}"}

            response = requests.get(url, headers=headers)
            response.raise_for_status()

            playlists = response.json()

            playlist_details = [
                {"name": item["name"], "id": item["id"]} for item in playlists["items"]
            ]

            # # Extract playlist names
            # playlist_names = [item["name"] for item in playlists["items"]]

            return f"Here the playlist details: {playlist_details}"

        except Exception as e:
            logger.warning(f"Error invoking get_spotify_playlists: {e}")
            return f"Error: {e}"

    def start_playlist_playback(self, playlist_id: str) -> str:
        """
        Useful for initiating playback of a playlist on a user's device.
        Args:
            playlist_id : str : The id of the playlist to play

        Returns:
            str: the status of the playback
        """
        import time

        try:
            url = f"https://api.spotify.com/v1/me/player/devices"

            headers = {"Authorization": f"Bearer {self.access_token}"}

            response = requests.get(url, headers=headers)
            response.raise_for_status()

            devices = response.json().get("devices", [])
            if not devices:
                return "You have to open at least one device to play the playlist."

            # choose always the first one
            device_id = devices[0]["id"]
            device_name = devices[0]["name"]

            url = f"https://api.spotify.com/v1/me/player/play?device_id={device_id}"
            headers = {
                "Authorization": f"Bearer {self.access_token}",
                "Content-Type": "application/json",
            }
            data = {
                "context_uri": f"spotify:playlist:{playlist_id}",
                "offset": {"position": 0},
                "position_ms": 0,
            }

            # check if the playlist is available before starting the playback
            # TODO: IMPROVE !!!!
            counter = 0
            max_counter = 5
            while counter < max_counter:
                response = requests.get(
                    f"https://api.spotify.com/v1/playlists/{playlist_id}",
                    headers=headers,
                )

                if response.status_code == 200:
                    break
                else:
                    counter += 1
                    time.sleep(1)

            # start the playback
            response = requests.put(url, headers=headers, json=data)

            response.raise_for_status()
            return f"Playback started successfully on device: {device_name}"

        except Exception as e:
            print(f"Error invoking play_playlist: {e}")
            return f"Error starting playback: {e}"

    def get_top_artists_and_top_genres_time_range(
        self, time_range="medium_term", limit=10
    ) -> str:
        """
        Useful to get the information about top artists and genres followed by the user
        Use this when you want to the long, medium or short period of the user in music

        Args:
            time_range : str : The time range of the data. Affinities are computed over three time frames: long_term: ~1 year of data , medium_term: ~last 6 months, short_term: ~last 4 weeks
            limit : int : The number of artists to return

        Returns:
            str: the information of top genres and artists listed by user in the given time range
        """
        try:
            url = f"https://api.spotify.com/v1/me/top/artists?time_range={time_range},limit={limit}"
            headers = {"Authorization": f"Bearer {self.access_token}"}

            artists = []
            genres = []

            while url:
                response = requests.get(url, headers=headers)
                response.raise_for_status()
                data = response.json()

                for artist in data["items"]:
                    artist_genres = artist["genres"]
                    artists.append({"name": artist["name"], "genres": artist_genres})
                    genres.extend(artist_genres)

                url = data.get("next")

            genre_counts = Counter(genres)
            top_5_genres = genre_counts.most_common(5)

            genre_to_artists = defaultdict(list)

            for artist in artists:
                for genre in artist["genres"]:
                    if genre in dict(top_5_genres):
                        genre_to_artists[genre].append(artist["name"])

            top_5_genre_artists = {}
            for genre, _ in top_5_genres:
                top_5_genre_artists[genre] = genre_to_artists[genre][:5]

            return f"These are the top 5 artists by genres in the {time_range} range {top_5_genres}, {top_5_genre_artists}"
        except Exception as e:
            logger.warning(f"Error invoking get_followed_artists_and_top_genres: {e}")
            return f"Error: {e}"

    def get_followed_artists_and_top_genres_all_life(self) -> str:
        """
        Useful to get the information about top 5 artists and genres followed by the user
        Use this when you want to the all life of the user in music

        Args:
            None

        Returns:
            str: the information of top genres and artists listed by user

        """
        try:
            url = "https://api.spotify.com/v1/me/following?type=artist"
            headers = {"Authorization": f"Bearer {self.access_token}"}

            artists = []
            genres = []

            while url:
                response = requests.get(url, headers=headers)
                response.raise_for_status()
                data = response.json()

                for artist in data["artists"]["items"]:
                    artist_genres = artist["genres"]
                    artists.append({"name": artist["name"], "genres": artist_genres})
                    genres.extend(artist_genres)

                url = data["artists"]["next"]

            genre_counts = Counter(genres)
            top_5_genres = genre_counts.most_common(5)

            genre_to_artists = defaultdict(list)

            for artist in artists:
                for genre in artist["genres"]:
                    if genre in dict(top_5_genres):
                        genre_to_artists[genre].append(artist["name"])

            top_5_genre_artists = {}
            for genre, _ in top_5_genres:
                top_5_genre_artists[genre] = genre_to_artists[genre][:5]

            return f"These are the top 5 artists by genres {top_5_genres}, {top_5_genre_artists}"

        except Exception as e:
            logger.warning(f"Error invoking get_followed_artists_and_top_genres: {e}")
            return f"Error: {e}"

    # def get_playlist_tracks(auth_token, playlist_id):
    #     url = f"https://api.spotify.com/v1/playlists/{playlist_id}/tracks"
    #     headers = {"Authorization": f"Bearer {auth_token}"}

    #     response = requests.get(url, headers=headers)
    #     response.raise_for_status()
    #     return response.json()

    # def get_song_titles_from_playlists(auth_token):
    #     playlists = get_spotify_playlists(auth_token)
    #     song_titles = []

    #     for item in playlists["items"]:
    #         playlist_id = item["id"]
    #         tracks = get_playlist_tracks(auth_token, playlist_id)

    #         for track_item in tracks["items"]:
    #             song_title = track_item["track"]["name"]
    #             song_titles.append(song_title)

    #     return song_titles
