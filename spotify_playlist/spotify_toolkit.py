from typing import List, Dict, Any, Union, Optional
from agno.tools import Toolkit
from agno.utils.log import logger
import httpx
from collections import Counter, defaultdict
import time


class SpotifyPlaylistTools(Toolkit):
    def __init__(self, access_token: str):
        super().__init__(name="spotify_playlist_tools")
        self.register(self.get_user_id)
        self.register(self.search_songs_uris)
        self.register(self.create_playlist_by_uris)
        self.register(self.get_spotify_playlist_info)
        self.register(self.start_playlist_playback)
        self.register(self.get_top_artists_and_top_genres_time_range)
        self.register(self.get_followed_artists_and_top_genres_all_life)
        self.register(self.get_recently_played_tracks)
        self.register(self.get_friday_new_releases)

        self.access_token = access_token
        self.base_url = "https://api.spotify.com/v1"
        self.headers = {"Authorization": f"Bearer {self.access_token}"}

    def _api_request(
        self, method: str, url: str, **kwargs
    ) -> Union[Dict[str, Any], str]:
        """Helper method to make requests to the Spotify API."""
        headers = self.headers.copy()
        if "json" in kwargs or "data" in kwargs:
            headers["Content-Type"] = "application/json"

        try:
            response = httpx.request(method, url, headers=headers, **kwargs)
            logger.debug(f"Request to {url} with status {response.status_code}")
            response.raise_for_status()
            if response.status_code == 204 or not response.content:
                return {}
            return response.json()
        except httpx.HTTPStatusError as e:
            msg = (
                f"API request failed with status {e.response.status_code}:"
                f" {e.response.text}"
            )
            logger.warning(msg)
            return f"Error: {msg}"
        except Exception as e:
            logger.warning(f"An unexpected error occurred: {e}")
            return f"Error: {e}"

    def get_user_id(self) -> str:
        """
        Make a request to Spotify API to get user information.

        Returns:
            str: The user ID of the Spotify user or an error message.
        """
        logger.info("Running get_user_id")
        result = self._api_request("GET", f"{self.base_url}/me")

        if isinstance(result, str):
            return result

        if "id" in result:
            return result["id"]

        logger.warning("Could not find user ID in response.")
        return "Error: Could not find user ID in response."

    def search_songs_uris(self, song_titles: List[str]) -> Union[List[str], str]:
        """
        Search for song URIs on Spotify.

        Args:
            song_titles: A list of song titles to search for.

        Returns:
            A list of song URIs found, or an error message if a general error occurs.
            If a single song is not found, it is skipped.
        """
        logger.info("Running search_songs_uris")
        songs_uris = []
        for song_title in song_titles:
            params = {"q": song_title, "type": "track", "market": "IT", "limit": 1}
            result = self._api_request("GET", f"{self.base_url}/search", params=params)

            if isinstance(result, str):
                logger.warning(
                    f"Failed to fetch track URI for '{song_title}': {result}"
                )
                continue

            if result.get("tracks", {}).get("items"):
                track_uri = result["tracks"]["items"][0]["uri"]
                songs_uris.append(track_uri)
            else:
                logger.info(f"No track found for '{song_title}'.")

        return songs_uris

    def create_playlist_by_uris(
        self,
        songs_uris: List[str],
        playlist_name="made by NTTLuke (with Phidata)",
    ) -> str:
        """
        Create a playlist on Spotify with a given list of song URIs.

        Args:
            songs_uris: A list of song URIs to add to the playlist.
            playlist_name: The name for the new playlist.

        Returns:
            A message indicating success or failure, including the playlist ID.
        """
        logger.info("Running create_playlist_by_uris")

        user_id = self.get_user_id()
        if user_id.startswith("Error:"):
            return f"Error creating playlist: could not get user ID. Details: {user_id}"

        playlist_data = {
            "name": playlist_name,
            "description": "generated by phidata",
            "public": False,
        }

        create_playlist_url = f"{self.base_url}/users/{user_id}/playlists"
        result = self._api_request("POST", create_playlist_url, json=playlist_data)

        if isinstance(result, str):
            return f"Error creating playlist: {result}"

        playlist_id = result.get("id")
        if not playlist_id:
            return "Error: Playlist created but no ID was returned."

        logger.info(f"Playlist created successfully with ID: {playlist_id}")

        if not songs_uris:
            logger.info("No songs to add to the playlist.")
            return f"Created a new empty playlist with Playlist ID={playlist_id}"

        add_songs_url = f"{self.base_url}/playlists/{playlist_id}/tracks"
        add_songs_data = {"uris": songs_uris, "position": 0}

        add_result = self._api_request("POST", add_songs_url, json=add_songs_data)

        if isinstance(add_result, str):
            return (
                f"Playlist created with ID {playlist_id}, but failed to add songs."
                f" Error: {add_result}"
            )

        logger.info("Songs added to the playlist successfully.")
        return f"Created a new playlist with Playlist ID={playlist_id}"

    def get_spotify_playlist_info(
        self, max_number: int = 5
    ) -> Union[List[Dict[str, str]], str]:
        """
        Get a list of the user's playlists.

        Args:
            max_number: The maximum number of playlists to return.

        Returns:
            A list of playlist details (name and ID), or an error message.
        """
        logger.info("Running get_spotify_playlist_info")
        url = f"{self.base_url}/me/playlists"
        params = {"limit": max_number}
        result = self._api_request("GET", url, params=params)

        if isinstance(result, str):
            return result

        if "items" in result:
            return [
                {"name": item["name"], "id": item["id"]} for item in result["items"]
            ]

        logger.warning("Could not find 'items' in playlist response.")
        return "Error: Could not parse playlists from response."

    def start_playlist_playback(self, playlist_id: str) -> str:
        """
        Initiate playback of a playlist on a user's active device.

        Args:
            playlist_id: The ID of the playlist to play.

        Returns:
            The status of the playback operation.
        """
        logger.info("Running start_playlist_playback")

        devices_result = self._api_request("GET", f"{self.base_url}/me/player/devices")
        if isinstance(devices_result, str):
            return f"Error getting devices: {devices_result}"

        devices = devices_result.get("devices", [])
        if not devices:
            return "You have to open at least one device to play the playlist."

        device_id = devices[0]["id"]
        device_name = devices[0]["name"]
        logger.info(f"Found device: {device_name} ({device_id})")

        # A new playlist might not be available immediately. We poll for a few seconds.
        playlist_url = f"{self.base_url}/playlists/{playlist_id}"
        max_retries = 5
        for i in range(max_retries):
            try:
                response = httpx.get(playlist_url, headers=self.headers)
                if response.status_code == 200:
                    logger.info("Playlist is available for playback.")
                    break
                logger.debug(
                    f"Playlist not ready yet (status: {response.status_code}), retrying..."
                )
            except Exception as e:
                logger.warning(f"Error checking playlist status: {e}")

            if i == max_retries - 1:
                return "Error: Playlist did not become available for playback in time."
            time.sleep(1)

        play_url = f"{self.base_url}/me/player/play"
        play_data = {
            "context_uri": f"spotify:playlist:{playlist_id}",
            "offset": {"position": 0},
            "position_ms": 0,
        }
        play_result = self._api_request(
            "PUT", play_url, params={"device_id": device_id}, json=play_data
        )

        if isinstance(play_result, str):
            return f"Error starting playback: {play_result}"

        return f"Playback started successfully on device: {device_name}"

    def _get_and_process_artists(
        self, initial_url: str, result_key: Optional[str]
    ) -> Union[Dict[str, Any], str]:
        """
        Fetches and processes artist data from a paginated Spotify API endpoint.

        Args:
            initial_url: The first URL to fetch from.
            result_key: The key in the response where the list of items is located.
                        (e.g., 'artists' for followed artists endpoint). If None, the
                        root of the response is used.

        Returns:
            A dictionary with top genres and artists, or an error string.
        """
        artists = []
        genres = []
        url: Optional[str] = initial_url

        while url:
            result = self._api_request("GET", url)
            if isinstance(result, str):
                return result

            data_source = result
            if result_key:
                if result_key not in result:
                    return f"Error: key '{result_key}' not in response."
                data_source = result[result_key]

            for artist in data_source.get("items", []):
                artist_genres = artist.get("genres", [])
                artists.append({"name": artist["name"], "genres": artist_genres})
                genres.extend(artist_genres)

            url = data_source.get("next")

        genre_counts = Counter(genres)
        top_5_genres = genre_counts.most_common(5)

        genre_to_artists = defaultdict(list)
        for artist in artists:
            for genre in artist["genres"]:
                if genre in dict(top_5_genres):
                    genre_to_artists[genre].append(artist["name"])

        top_5_genre_artists = {
            genre: genre_to_artists[genre][:5] for genre, _ in top_5_genres
        }

        return {
            "top_genres": top_5_genres,
            "top_artists_by_genre": top_5_genre_artists,
        }

    def get_top_artists_and_top_genres_time_range(
        self, time_range="medium_term", limit=10
    ) -> str:
        """
        Gets the user's top artists and genres over a specific time range.

        Args:
            time_range: 'long_term' (~1yr), 'medium_term' (~6mo), or 'short_term' (~4wk).
            limit: The number of top artists to retrieve.

        Returns:
            A summary of the user's top genres and artists.
        """
        logger.info(f"Getting top artists and genres for time range: {time_range}")
        # Note: The 'limit' parameter for top artists applies to the initial fetch,
        # but pagination will be followed to get a complete list for genre analysis.
        url = f"{self.base_url}/me/top/artists?time_range={time_range}&limit={limit}"

        result = self._get_and_process_artists(url, result_key=None)

        if isinstance(result, str):
            return result

        return (
            f"Top 5 genres for {time_range}: {result['top_genres']}. "
            f"Top artists for these genres: {result['top_artists_by_genre']}"
        )

    def get_followed_artists_and_top_genres_all_life(self) -> str:
        """
        Gets top genres based on all artists the user follows.

        Returns:
            A summary of top genres and corresponding followed artists.
        """
        logger.info("Getting followed artists and top genres")
        url = f"{self.base_url}/me/following?type=artist&limit=5"
        result = self._get_and_process_artists(url, result_key="artists")

        if isinstance(result, str):
            return result

        return (
            f"Top 5 genres from followed artists: {result['top_genres']}. "
            f"Followed artists for these genres: {result['top_artists_by_genre']}"
        )

    def get_recently_played_tracks(self, limit: int = 10) -> str:
        """
        Get the user's recently played tracks and analyze them.

        Args:
            limit: The number of recently played tracks to retrieve (max 50, default 10).

        Returns:
            A summary of recently played tracks, including top genres, as a string.
        """
        logger.info(f"Getting {limit} recently played tracks")

        # Get recently played tracks
        url = f"{self.base_url}/me/player/recently-played"
        params = {"limit": min(limit, 50)}  # Spotify API limit is 50
        result = self._api_request("GET", url, params=params)

        if isinstance(result, str):
            return result

        if "items" not in result:
            return "Error: Could not find recently played tracks in response."

        tracks_info = []
        artist_ids = set()

        # Extract track information and collect artist IDs
        for item in result["items"]:
            track = item.get("track", {})
            if not track:
                continue

            track_name = track.get("name", "Unknown")
            artists = track.get("artists", [])
            artist_names = [artist.get("name", "Unknown") for artist in artists]

            # Collect artist IDs for genre lookup
            for artist in artists:
                if artist.get("id"):
                    artist_ids.add(artist["id"])

            tracks_info.append(
                {
                    "title": track_name,
                    "artists": artist_names,
                    "artist_ids": [
                        artist.get("id") for artist in artists if artist.get("id")
                    ],
                    "played_at": item.get("played_at", "Unknown"),
                    "genres": [],  # Will be populated later
                }
            )

        # Batch fetch artist information to get genres (Spotify API supports up to 50 IDs)
        if artist_ids:
            artist_ids_list = list(artist_ids)
            genres_by_artist = {}

            # Process in batches of 50 (Spotify API limit)
            for i in range(0, len(artist_ids_list), 50):
                batch_ids = artist_ids_list[i : i + 50]
                artists_url = f"{self.base_url}/artists"
                params = {"ids": ",".join(batch_ids)}

                artists_result = self._api_request("GET", artists_url, params=params)

                if isinstance(artists_result, str):
                    logger.warning(f"Failed to fetch artist genres: {artists_result}")
                    continue

                for artist in artists_result.get("artists", []):
                    artist_id = artist.get("id")
                    if artist_id:
                        genres_by_artist[artist_id] = artist.get("genres", [])

            # Assign genres to tracks
            for track in tracks_info:
                track_genres = []
                for artist_id in track["artist_ids"]:
                    if artist_id in genres_by_artist:
                        track_genres.extend(genres_by_artist[artist_id])

                # Remove duplicates and keep the list ordered
                seen = set()
                track["genres"] = [
                    g for g in track_genres if not (g in seen or seen.add(g))
                ]

                # Remove artist_ids from final output as they're not needed
                del track["artist_ids"]

        # Create a summary string
        all_genres = []
        for track in tracks_info:
            all_genres.extend(track["genres"])

        genre_counts = Counter(all_genres)
        top_genres = genre_counts.most_common(5)

        summary_lines = [f"Analyzed {len(tracks_info)} recently played tracks."]

        if top_genres:
            top_genres_str = ", ".join(
                [f"{genre} ({count} times)" for genre, count in top_genres]
            )
            summary_lines.append(f"Top 5 genres from recent tracks: {top_genres_str}.")
        else:
            summary_lines.append("No genre information found for recent tracks.")

        if tracks_info:
            summary_lines.append("Recently played tracks:")
            for i, track in enumerate(tracks_info, 1):
                title = track["title"]
                artists = ", ".join(track["artists"])
                summary_lines.append(f"{i}. '{title}' by {artists}")

        return "\n".join(summary_lines)

    def get_friday_new_releases(self, limit: int = 20, country: str = "IT") -> str:
        """
        Get new album releases from Friday (typical release day for new music).
        Creates a playlist with tracks from these new releases.

        Args:
            limit: Number of new releases to fetch (max 50)
            country: ISO 3166-1 alpha-2 country code for market

        Returns:
            A summary of new releases and playlist creation status.
        """
        logger.info(f"Getting Friday new releases for {country}")
        
        # Get new releases
        url = f"{self.base_url}/browse/new-releases"
        params = {
            "limit": min(limit, 50),
            "country": country
        }
        
        result = self._api_request("GET", url, params=params)
        
        if isinstance(result, str):
            return result
        
        albums = result.get("albums", {}).get("items", [])
        if not albums:
            return "No new releases found."
        
        # Collect tracks from new albums
        all_track_uris = []
        release_summary = []
        
        for album in albums:
            album_id = album.get("id")
            album_name = album.get("name", "Unknown")
            artists = ", ".join([artist.get("name", "Unknown") for artist in album.get("artists", [])])
            release_date = album.get("release_date", "Unknown")
            
            # Get tracks from the album
            tracks_url = f"{self.base_url}/albums/{album_id}/tracks"
            tracks_params = {"limit": 50}
            tracks_result = self._api_request("GET", tracks_url, params=tracks_params)
            
            if isinstance(tracks_result, str):
                logger.warning(f"Failed to get tracks for album {album_name}")
                continue
            
            tracks = tracks_result.get("items", [])
            track_uris = [track.get("uri") for track in tracks if track.get("uri")]
            
            if track_uris:
                # Add first 2-3 tracks from each album to avoid playlist being too long
                all_track_uris.extend(track_uris[:3])
                release_summary.append(f"'{album_name}' by {artists} (Released: {release_date})")
        
        if not all_track_uris:
            return "Found new releases but couldn't extract any tracks."
        
        # Create playlist with new releases
        from datetime import datetime
        today = datetime.now().strftime("%Y-%m-%d")
        playlist_name = f"Friday New Releases - {today}"
        
        # Get user ID
        user_id = self.get_user_id()
        if isinstance(user_id, str) and user_id.startswith("Error"):
            return user_id
        
        # Create the playlist
        playlist_url = f"{self.base_url}/users/{user_id}/playlists"
        playlist_data = {
            "name": playlist_name,
            "description": f"Fresh releases for your Friday! Updated {today}",
            "public": False
        }
        
        playlist_result = self._api_request("POST", playlist_url, json=playlist_data)
        
        if isinstance(playlist_result, str):
            return f"Found releases but failed to create playlist: {playlist_result}"
        
        playlist_id = playlist_result.get("id")
        if not playlist_id:
            return "Failed to create playlist - no ID returned"
        
        # Add tracks to playlist (Spotify limits to 100 tracks per request)
        add_tracks_url = f"{self.base_url}/playlists/{playlist_id}/tracks"
        
        # Take only first 50 tracks to keep playlist manageable
        tracks_to_add = all_track_uris[:50]
        add_result = self._api_request("POST", add_tracks_url, json={"uris": tracks_to_add})
        
        if isinstance(add_result, str):
            return f"Created playlist but failed to add tracks: {add_result}"
        
        # Prepare summary
        summary = [
            f"✨ Created playlist: '{playlist_name}' with {len(tracks_to_add)} tracks",
            f"\nNew releases included ({len(release_summary)} albums):"
        ]
        summary.extend(release_summary[:10])  # Show first 10 albums
        
        if len(release_summary) > 10:
            summary.append(f"... and {len(release_summary) - 10} more albums")
        
        return "\n".join(summary)

    # def get_playlist_tracks(auth_token, playlist_id):
    #     url = f"https://api.spotify.com/v1/playlists/{playlist_id}/tracks"
    #     headers = {"Authorization": f"Bearer {auth_token}"}

    #     response = httpx.get(url, headers=headers)
    #     response.raise_for_status()
    #     return response.json()

    # def get_song_titles_from_playlists(auth_token):
    #     playlists = get_spotify_playlists(auth_token)
    #     song_titles = []

    #     for item in playlists["items"]:
    #         playlist_id = item["id"]
    #         tracks = get_playlist_tracks(auth_token, playlist_id)

    #         for track_item in tracks["items"]:
    #             song_title = track_item["track"]["name"]
    #             song_titles.append(song_title)

    #     return song_titles
